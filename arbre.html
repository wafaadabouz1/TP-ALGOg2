<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>B+ Arbre — Visualiseur Complet</title>
<style>
:root {
  --bg: #ffffff;
  --card: #f8f6ff;
  --accent: #7b2cbf;
  --accent-hover: #9d4edd;
  --muted: #6b6b6b;
  --text: #2d0057;
  --border: #e0e0e0;
}

* {
  box-sizing: border-box;
  font-family: 'Inter', 'Segoe UI', Roboto, Arial, sans-serif;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding: 15px;
}

.app {
  width: 100%;
  max-width: 1600px;
  background: var(--card);
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
  border: 1px solid var(--border);
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
}

header h1 {
  font-size: 22px;
  font-weight: 700;
  color: var(--accent);
}

.controls {
  display: flex;
  gap: 15px;
  align-items: stretch;
  margin-bottom: 15px;
}

.card {
  background: #fff;
  padding: 15px;
  border-radius: 10px;
  border: 1px solid var(--border);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.03);
}

.controls-left {
  flex: 0 0 320px;
}

.controls-right {
  flex: 1;
  min-height: 600px;
}

label {
  font-size: 13px;
  color: var(--muted);
  display: block;
  margin-bottom: 6px;
}

input[type=number],
input[type=text],
select {
  width: 100%;
  padding: 8px;
  border-radius: 8px;
  border: 1px solid #ccc;
  background: #fff;
  color: var(--text);
  font-weight: 500;
  transition: 0.2s;
  font-size: 13px;
}

input:focus,
select:focus {
  border-color: var(--accent);
  outline: none;
  box-shadow: 0 0 4px rgba(155, 78, 221, 0.3);
}

button {
  background: linear-gradient(90deg, var(--accent), var(--accent-hover));
  border: none;
  padding: 9px 14px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.25s ease;
  box-shadow: 0 3px 8px rgba(155, 78, 221, 0.3);
  font-size: 13px;
  flex: 1;
}

button:hover {
  transform: translateY(-1px);
  box-shadow: 0 5px 12px rgba(155, 78, 221, 0.4);
}

button.secondary {
  background: transparent;
  border: 1px solid var(--accent);
  color: var(--accent);
}

button.secondary:hover {
  background: var(--accent);
  color: #fff;
}

button.small {
  padding: 6px 12px;
  font-size: 12px;
  flex: none;
}

.row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.row-buttons {
  display: flex;
  gap: 6px;
}

.canvas {
  background: #faf9ff;
  padding: 15px;
  border-radius: 10px;
  border: 1px solid var(--border);
  height: 100%;
}

#svgRoot {
  width: 100%;
  height: 550px;
  background: linear-gradient(180deg, rgba(123, 44, 191, 0.05), transparent);
  border-radius: 10px;
}

.legend {
  font-size: 12px;
  color: var(--muted);
  margin-top: 8px;
}

.footer {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  margin-top: 15px;
}

.node {
  fill: #ede9fe;
  stroke: #7b2cbf;
  stroke-width: 1.6;
}

.leaf {
  fill: #f3e8ff;
  stroke: #9d4edd;
}

.node-text {
  font-size: 14px;
  fill: var(--accent);
  font-weight: 600;
}

.link {
  stroke: rgba(155, 78, 221, 0.4);
  stroke-width: 1.5;
}

.hl {
  stroke: #f9c74f;
  stroke-width: 3;
}

.arrow {
  stroke: #ffd166;
  stroke-width: 2.5;
  marker-end: url(#arrowhead);
}

.msg {
  color: var(--muted);
  font-size: 13px;
  margin-top: 8px;
}

.error {
  color: #e63946;
  font-size: 12px;
  margin-top: 4px;
}

.array-display {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  padding: 12px;
  margin-top: 12px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  color: #495057;
  max-height: 90px;
  overflow-y: auto;
}

.array-item {
  display: inline-block;
  padding: 4px 8px;
  margin: 2px;
  background: #e9ecef;
  border-radius: 4px;
  border: 1px solid #ced4da;
  font-size: 12px;
  font-weight: 600;
}

.stats {
  display: flex;
  gap: 20px;
  align-items: center;
  padding: 8px 15px;
  font-size: 13px;
}

.stat-item {
  text-align: center;
}

.stat-label {
  font-size: 11px;
  color: var(--muted);
}

.stat-value {
  font-weight: 700;
  color: var(--accent);
  font-size: 16px;
}

.operations {
  max-height: 80px;
  overflow-y: auto;
  font-size: 12px;
  line-height: 1.4;
}

.help-text {
  font-size: 12px;
  line-height: 1.4;
}

.list-input {
  font-size: 13px;
  height: 60px;
  resize: vertical;
}

.list-example {
  font-size: 11px;
  color: var(--muted);
  margin-top: 4px;
}

.single-line-table {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  align-items: center;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 6px;
  border: 1px solid #e9ecef;
  max-height: 60px;
  overflow-y: auto;
}

.table-item {
  padding: 3px 6px;
  background: #e9ecef;
  border-radius: 4px;
  border: 1px solid #ced4da;
  font-size: 11px;
  font-weight: 600;
}

.save-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}

.save-buttons {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>B+ Arbre — Visualiseur (Insert / Search / Delete)</h1>
  <div class="card stats">
    <div class="stat-item">
      <div class="stat-label">Ordre</div>
      <div id="currentOrder" class="stat-value">3</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Hauteur</div>
      <div id="height" class="stat-value">1</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Nombre de clés</div>
      <div id="keyCount" class="stat-value">0</div>
    </div>
  </div>
</header>

<div class="controls">
  <div class="card controls-left">
    <div style="margin-bottom:12px">
      <label>Ordre du B+ arbre (m - impair seulement)</label>
      <div class="row">
        <input id="orderInput" type="number" min="3" max="9" value="3" step="2" />
        <button id="createTreeBtn" class="small">Créer</button>
      </div>
      <div id="orderError" class="error" style="display:none">L'ordre doit être impair (3,5,7,9)</div>
    </div>
    
    <div style="margin-bottom:8px">
      <label>Clé unique</label>
      <input id="keyInput" type="number" placeholder="ex: 42" />
    </div>
    
    <div class="row-buttons">
      <button id="insertBtn">Insérer</button>
      <button id="deleteBtn" class="secondary">Supprimer</button>
      <button id="searchBtn" class="secondary">Rechercher</button>
    </div>
    
    <div style="margin-top:12px">
      <label>Liste de valeurs (séparées par des virgules)</label>
      <textarea id="listInput" class="list-input" placeholder="ex: 10, 25, 42, 67, 89"></textarea>
      <div class="list-example">Exemple: 10,25,42,67,89 ou 5-10-15-20</div>
    </div>
    
    <div class="row-buttons" style="margin-top:8px">
      <button id="insertListBtn" class="secondary">Insérer Liste</button>
      <button id="shuffleBtn" class="secondary">Aléatoire</button>
      <button id="quickSortBtn" class="secondary">Tri B+ TREE</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>
    
    <div class="msg" id="feedback">Prêt. Arbre d'ordre 3 créé.</div>

    <div id="arrayDisplay" style="display:none">
      <div style="font-weight:700;margin-bottom:6px;color:var(--accent);font-size:12px">Liste triée (parcours des feuilles):</div>
      <div id="sortedArray" class="single-line-table"></div>
    </div>

    <div class="save-section">
      <div style="font-weight:700;margin-bottom:6px;color:var(--accent);font-size:12px">Sauvegarde</div>
      <div class="save-buttons">
        <button id="saveTreeBtn" class="small secondary">Sauvegarder Arbre</button>
        <button id="loadTreeBtn" class="small secondary">Charger Arbre</button>
      </div>
      <div id="saveFeedback" class="msg"></div>
    </div>
  </div>

  <div class="card controls-right">
    <div class="canvas">
      <svg id="svgRoot" viewBox="0 0 1400 650" preserveAspectRatio="xMidYMid meet">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="8" refX="10" refY="4" orient="auto" fill="#ffd166">
            <polygon points="0 0, 10 4, 0 8"></polygon>
          </marker>
        </defs>
      </svg>
      <div class="legend">Feuilles chaînées → (flèches orientées). Cliquez sur un nœud pour surbrillance.</div>
    </div>
  </div>
</div>

<div class="footer">
  <div class="card" style="flex:1">
    <div style="font-weight:700;font-size:13px">Historique / Opérations</div>
    <div id="history" class="operations">— Arbre d'ordre 3 créé</div>
  </div>
  <div class="card" style="flex:0 0 220px">
    <div style="font-weight:700;margin-bottom:6px;font-size:13px">Aide rapide</div>
    <div class="help-text">
      • Clé unique ou liste de valeurs<br>
      • Ordre m impair seulement<br>
      • Pas de doublons autorisés<br>
      • Sauvegarde/Chargement d'arbre
    </div>
  </div>
</div>
</div>

<script>
// ======== Classe B+ Tree CORRIGÉE =========
class BPlusNode {
  constructor(isLeaf = false) {
    this.isLeaf = isLeaf;
    this.keys = [];
    this.children = [];
    this.next = null;
  }
}

class BPlusTree {
  constructor(order = 3) {
    this.order = Math.max(3, order);
    if (this.order % 2 === 0) {
      this.order = this.order - 1;
    }
    this.root = new BPlusNode(true);
    this.keyCount = 0;
  }

  updateOrder(m) {
    const newOrder = Math.max(3, m);
    this.order = (newOrder % 2 === 0) ? newOrder - 1 : newOrder;
    this.root = new BPlusNode(true);
    this.keyCount = 0;
  }

  search(k) {
    let n = this.root;
    while (!n.isLeaf) {
      let i = 0;
      while (i < n.keys.length && k >= n.keys[i]) i++;
      n = n.children[i];
    }
    for (let i = 0; i < n.keys.length; i++) {
      if (n.keys[i] === k) {
        return { found: true, node: n };
      }
    }
    return { found: false, node: n };
  }

  insert(k) {
    if (this.search(k).found) return false;
    const s = this._ins(this.root, k);
    if (s) {
      const r = new BPlusNode(false);
      r.keys = [s.key];
      r.children = [s.left, s.right];
      this.root = r;
    }
    this.keyCount++;
    return true;
  }

  insertList(values) {
    let inserted = 0;
    let duplicates = 0;

    for (const value of values) {
      if (this.insert(value)) {
        inserted++;
      } else {
        duplicates++;
      }
    }

    return { inserted, duplicates };
  }

  _ins(n, k) {
    if (n.isLeaf) {
      let i = 0;
      while (i < n.keys.length && n.keys[i] < k) i++;
      n.keys.splice(i, 0, k);
      n.children.splice(i, 0, null);

      if (n.keys.length > this.order - 1) {
        const m = Math.ceil((this.order - 1) / 2);
        const r = new BPlusNode(true);
        r.keys = n.keys.splice(m);
        r.children = n.children.splice(m);
        r.next = n.next;
        n.next = r;
        return { key: r.keys[0], left: n, right: r };
      }
      return null;
    } else {
      let i = 0;
      while (i < n.keys.length && k >= n.keys[i]) i++;
      const s = this._ins(n.children[i], k);
      if (!s) return null;
      let j = 0;
      while (j < n.keys.length && n.keys[j] < s.key) j++;
      n.keys.splice(j, 0, s.key);
      n.children.splice(j + 1, 0, s.right);
      n.children[j] = s.left;

      if (n.keys.length > this.order - 1) {
        const mid = Math.floor(n.keys.length / 2);
        const promo = n.keys[mid];
        const r = new BPlusNode(false);
        r.keys = n.keys.splice(mid + 1);
        r.children = n.children.splice(mid + 1);
        n.keys.splice(mid);
        return { key: promo, left: n, right: r };
      }
      return null;
    }
  }

  // ========= SUPPRESSION CORRIGÉE =========
  delete(k) {
    const searchResult = this.search(k);
    if (!searchResult.found) return false;

    this._deleteKey(this.root, k);
    this.keyCount = Math.max(0, this.keyCount - 1);

    if (!this.root.isLeaf && this.root.keys.length === 0) {
      this.root = this.root.children[0] || new BPlusNode(true);
    }

    return true;
  }

  _deleteKey(node, key) {
    if (node.isLeaf) {
      const index = node.keys.indexOf(key);
      if (index !== -1) {
        node.keys.splice(index, 1);
        node.children.splice(index, 1);
        
        if (node.keys.length < Math.ceil((this.order - 1) / 2)) {
          this._fixUnderflowLeaf(node);
        }
        return true;
      }
      return false;
    }

    let i = 0;
    while (i < node.keys.length && key >= node.keys[i]) {
      i++;
    }
    
    const deleted = this._deleteKey(node.children[i], key);
    
    if (deleted) {
      this._updateInternalKeys(node);
      
      if (node.children[i].keys.length < Math.ceil(this.order / 2) - 1) {
        this._fixUnderflowInternal(node, i);
      }
    }
    
    return deleted;
  }

  _fixUnderflowLeaf(leaf) {
    const parentInfo = this._findParent(this.root, leaf);
    if (!parentInfo) return;

    const { parent, childIndex } = parentInfo;

    if (childIndex > 0) {
      const leftSibling = parent.children[childIndex - 1];
      if (leftSibling.keys.length > Math.ceil((this.order - 1) / 2)) {
        this._borrowFromLeftLeaf(parent, childIndex, leftSibling, leaf);
        return;
      }
    }

    if (childIndex < parent.children.length - 1) {
      const rightSibling = parent.children[childIndex + 1];
      if (rightSibling.keys.length > Math.ceil((this.order - 1) / 2)) {
        this._borrowFromRightLeaf(parent, childIndex, leaf, rightSibling);
        return;
      }
    }

    if (childIndex > 0) {
      this._mergeLeaves(parent, childIndex - 1);
    } else if (childIndex < parent.children.length - 1) {
      this._mergeLeaves(parent, childIndex);
    }
  }

  _findParent(node, target, parent = null, childIndex = -1) {
    if (node === target) {
      return { parent, childIndex };
    }

    if (node.isLeaf) {
      return null;
    }

    for (let i = 0; i < node.children.length; i++) {
      const result = this._findParent(node.children[i], target, node, i);
      if (result) return result;
    }

    return null;
  }

  _borrowFromLeftLeaf(parent, childIndex, leftSibling, leaf) {
    const borrowedKey = leftSibling.keys.pop();
    const borrowedChild = leftSibling.children.pop();
    
    leaf.keys.unshift(borrowedKey);
    leaf.children.unshift(borrowedChild);
    
    parent.keys[childIndex - 1] = leaf.keys[0];
  }

  _borrowFromRightLeaf(parent, childIndex, leaf, rightSibling) {
    const borrowedKey = rightSibling.keys.shift();
    const borrowedChild = rightSibling.children.shift();
    
    leaf.keys.push(borrowedKey);
    leaf.children.push(borrowedChild);
    
    parent.keys[childIndex] = rightSibling.keys[0];
  }

  _mergeLeaves(parent, leftIndex) {
    const left = parent.children[leftIndex];
    const right = parent.children[leftIndex + 1];

    left.keys.push(...right.keys);
    left.children.push(...right.children);
    left.next = right.next;

    parent.keys.splice(leftIndex, 1);
    parent.children.splice(leftIndex + 1, 1);

    if (parent !== this.root && parent.keys.length < Math.ceil(this.order / 2) - 1) {
      this._fixUnderflowInternal(parent);
    }
  }

  _fixUnderflowInternal(node) {
    const parentInfo = this._findParent(this.root, node);
    if (!parentInfo) return;

    const { parent, childIndex } = parentInfo;

    if (childIndex > 0) {
      const leftSibling = parent.children[childIndex - 1];
      if (leftSibling.keys.length > Math.ceil(this.order / 2) - 1) {
        this._borrowFromLeftInternal(parent, childIndex, leftSibling, node);
        return;
      }
    }

    if (childIndex < parent.children.length - 1) {
      const rightSibling = parent.children[childIndex + 1];
      if (rightSibling.keys.length > Math.ceil(this.order / 2) - 1) {
        this._borrowFromRightInternal(parent, childIndex, node, rightSibling);
        return;
      }
    }

    if (childIndex > 0) {
      this._mergeInternal(parent, childIndex - 1);
    } else if (childIndex < parent.children.length - 1) {
      this._mergeInternal(parent, childIndex);
    }
  }

  _borrowFromLeftInternal(parent, childIndex, leftSibling, node) {
    const separatorKey = parent.keys[childIndex - 1];
    
    node.keys.unshift(separatorKey);
    const borrowedChild = leftSibling.children.pop();
    node.children.unshift(borrowedChild);
    
    parent.keys[childIndex - 1] = leftSibling.keys.pop();
  }

  _borrowFromRightInternal(parent, childIndex, node, rightSibling) {
    const separatorKey = parent.keys[childIndex];
    
    node.keys.push(separatorKey);
    const borrowedChild = rightSibling.children.shift();
    node.children.push(borrowedChild);
    
    parent.keys[childIndex] = rightSibling.keys.shift();
  }

  _mergeInternal(parent, leftIndex) {
    const left = parent.children[leftIndex];
    const right = parent.children[leftIndex + 1];
    const separatorKey = parent.keys[leftIndex];

    left.keys.push(separatorKey, ...right.keys);
    left.children.push(...right.children);

    parent.keys.splice(leftIndex, 1);
    parent.children.splice(leftIndex + 1, 1);

    if (parent === this.root && parent.keys.length === 0) {
      this.root = left;
    }
  }

  _updateInternalKeys(node) {
    if (!node.isLeaf) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.isLeaf && child.keys.length > 0) {
          if (i > 0) {
            node.keys[i - 1] = child.keys[0];
          }
        } else if (!child.isLeaf && child.keys.length > 0) {
          if (i > 0) {
            let largest = this._findLargestKey(child);
            node.keys[i - 1] = largest;
          }
        }
      }
    }
  }

  _findLargestKey(n) {
    while (!n.isLeaf) {
      n = n.children[n.children.length - 1];
    }
    return n.keys[n.keys.length - 1];
  }

  serialize() {
    const data = {
      order: this.order,
      keyCount: this.keyCount,
      root: this._serializeNode(this.root)
    };
    return JSON.stringify(data);
  }

  _serializeNode(node) {
    if (!node) return null;
    
    const serialized = {
      isLeaf: node.isLeaf,
      keys: [...node.keys],
      children: []
    };

    if (!node.isLeaf) {
      for (const child of node.children) {
        serialized.children.push(this._serializeNode(child));
      }
    }

    return serialized;
  }

  deserialize(data) {
    try {
      const parsed = JSON.parse(data);
      this.order = parsed.order;
      this.keyCount = parsed.keyCount;
      this.root = this._deserializeNode(parsed.root);
      
      this._rebuildLeafLinks();
      return true;
    } catch (e) {
      console.error('Erreur de désérialisation:', e);
      return false;
    }
  }

  _deserializeNode(data) {
    if (!data) return null;
    
    const node = new BPlusNode(data.isLeaf);
    node.keys = [...data.keys];
    
    if (data.isLeaf) {
      node.children = data.keys.map(() => null);
    } else {
      for (const childData of data.children) {
        node.children.push(this._deserializeNode(childData));
      }
    }
    
    return node;
  }

  _rebuildLeafLinks() {
    const leaves = [];
    this._collectLeaves(this.root, leaves);
    
    for (let i = 0; i < leaves.length - 1; i++) {
      leaves[i].next = leaves[i + 1];
    }
    if (leaves.length > 0) {
      leaves[leaves.length - 1].next = null;
    }
  }

  _collectLeaves(node, leaves) {
    if (node.isLeaf) {
      leaves.push(node);
    } else {
      for (const child of node.children) {
        this._collectLeaves(child, leaves);
      }
    }
  }
  
  getSortedValues() {
    const sorted = [];
    let currentNode = this.root;
    
    while (!currentNode.isLeaf) {
      currentNode = currentNode.children[0];
    }
    
    while (currentNode) {
      sorted.push(...currentNode.keys);
      currentNode = currentNode.next;
    }
    
    return sorted;
  }
  
  collectLevels() {
    const lv = [];
    const q = [{ n: this.root, l: 0 }];
    while (q.length) {
      const { n, l } = q.shift();
      if (!lv[l]) lv[l] = [];
      lv[l].push(n);
      if (!n.isLeaf) for (const c of n.children) q.push({ n: c, l: l + 1 });
    }
    return lv;
  }
  
  clear() {
    this.root = new BPlusNode(true);
    this.keyCount = 0;
  }
  
  getHeight() {
    let h = 0, n = this.root;
    while (n) { h++; if (n.isLeaf) break; n = n.children[0]; }
    return h;
  }
}

// ======== Rendu & Événements =========
const tree = new BPlusTree(3);
const svg = document.getElementById("svgRoot");
const fb = document.getElementById("feedback");
const hist = document.getElementById("history");
const keyInput = document.getElementById("keyInput");
const listInput = document.getElementById("listInput");
const orderInput = document.getElementById("orderInput");
const orderError = document.getElementById("orderError");
const createTreeBtn = document.getElementById("createTreeBtn");
const arrayDisplay = document.getElementById("arrayDisplay");
const sortedArray = document.getElementById("sortedArray");
const saveFeedback = document.getElementById("saveFeedback");

function stats() {
  document.getElementById("currentOrder").textContent = tree.order;
  document.getElementById("height").textContent = tree.getHeight();
  document.getElementById("keyCount").textContent = tree.keyCount;
}

function addHist(t) {
  hist.innerHTML = `${t}<br>` + hist.innerHTML;
}

function clearKeyInput() {
  keyInput.value = '';
}

function parseListInput(input) {
  return input.split(/[,;\s\-]+/)
    .map(val => val.trim())
    .filter(val => val !== '')
    .map(val => parseInt(val))
    .filter(val => !isNaN(val));
}

function displaySortedArray() {
  const sortedValues = tree.getSortedValues();
  
  if (sortedValues.length === 0) {
    sortedArray.innerHTML = '<span style="color:var(--muted)">Aucune valeur</span>';
  } else {
    sortedArray.innerHTML = sortedValues.map(val => 
      `<div class="table-item">${val}</div>`
    ).join('');
  }
  
  arrayDisplay.style.display = 'block';
}

function render() {
  svg.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="8" refX="10" refY="4" orient="auto" fill="#ffd166"><polygon points="0 0, 10 4, 0 8"></polygon></marker></defs>`;
  const lv = tree.collectLevels(), nodePos = new Map(), width = 1400, lh = 90;
  
  lv.forEach((ns, li) => {
    const y = 50 + li * lh, step = width / (ns.length + 1);
    ns.forEach((n, i) => {
      const x = (i + 1) * step;
      nodePos.set(n, { x, y });
      
      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("transform", `translate(${x}, ${y})`);
      
      const w = n.keys.length * 28 + 16, h = 32;
      const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      r.setAttribute("x", -w / 2);
      r.setAttribute("y", -h / 2);
      r.setAttribute("width", w);
      r.setAttribute("height", h);
      r.setAttribute("rx", 6);
      r.setAttribute("class", n.isLeaf ? "leaf node" : "node");
      g.appendChild(r);
      
      n.keys.forEach((k, ki) => {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", -w / 2 + 8 + ki * 28);
        t.setAttribute("y", 5);
        t.setAttribute("class", "node-text");
        t.textContent = k;
        g.appendChild(t);
      });
      
      svg.appendChild(g);
    });
  });
  
  lv.forEach((ns, li) => {
    if (li === lv.length - 1) return;
    ns.forEach(n => {
      const p = nodePos.get(n);
      n.children.forEach(c => {
        const cp = nodePos.get(c);
        if (!cp) return;
        const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
        l.setAttribute("x1", p.x);
        l.setAttribute("y1", p.y + 16);
        l.setAttribute("x2", cp.x);
        l.setAttribute("y2", cp.y - 16);
        l.setAttribute("class", "link");
        svg.appendChild(l);
      });
    });
  });
  
  let n = tree.root;
  while (!n.isLeaf) n = n.children[0];
  while (n && n.next) {
    const p = nodePos.get(n);
    const nx = nodePos.get(n.next);
    if (p && nx) {
      const a = document.createElementNS("http://www.w3.org/2000/svg", "line");
      a.setAttribute("x1", p.x + 35);
      a.setAttribute("y1", p.y + 20);
      a.setAttribute("x2", nx.x - 35);
      a.setAttribute("y2", nx.y + 20);
      a.setAttribute("class", "arrow");
      svg.appendChild(a);
    }
    n = n.next;
  }
  
  stats();
}

// Événements
document.getElementById("insertBtn").onclick = () => {
  const v = parseInt(keyInput.value);
  if (isNaN(v)) {
    fb.textContent = "Entrez un nombre valide.";
    return;
  }
  if (tree.insert(v)) {
    fb.textContent = `${v} inséré.`;
    addHist(`Insert ${v}`);
    clearKeyInput();
    arrayDisplay.style.display = 'none';
  } else {
    fb.textContent = `${v} existe déjà.`;
  }
  render();
};

document.getElementById("insertListBtn").onclick = () => {
  const input = listInput.value.trim();
  if (!input) {
    fb.textContent = "Entrez une liste de valeurs.";
    return;
  }
  
  const values = parseListInput(input);
  if (values.length === 0) {
    fb.textContent = "Aucun nombre valide trouvé.";
    return;
  }
  
  const result = tree.insertList(values);
  fb.textContent = `${result.inserted} valeurs insérées, ${result.duplicates} doublons ignorés.`;
  addHist(`Insert liste: ${result.inserted} valeurs`);
  listInput.value = '';
  arrayDisplay.style.display = 'none';
  render();
};

document.getElementById("deleteBtn").onclick = () => {
  const v = parseInt(keyInput.value);
  if (isNaN(v)) {
    fb.textContent = "Entrez un nombre valide.";
    return;
  }
  if (tree.delete(v)) {
    fb.textContent = `${v} supprimé.`;
    addHist(`Delete ${v}`);
    clearKeyInput();
    arrayDisplay.style.display = 'none';
  } else {
    fb.textContent = `${v} non trouvé.`;
  }
  render();
};

document.getElementById("searchBtn").onclick = () => {
  const v = parseInt(keyInput.value);
  if (isNaN(v)) {
    fb.textContent = "Entrez un nombre valide.";
    return;
  }
  const r = tree.search(v);
  fb.textContent = r.found ? `${v} trouvé.` : `${v} non trouvé.`;
  clearKeyInput();
};

document.getElementById("resetBtn").onclick = () => {
  tree.clear();
  fb.textContent = "Arbre réinitialisé.";
  addHist("Reset");
  arrayDisplay.style.display = 'none';
  saveFeedback.textContent = '';
  render();
};

document.getElementById("shuffleBtn").onclick = () => {
  let inserted = 0;
  for (let i = 0; i < 15; i++) {
    const val = Math.floor(Math.random() * 99);
    if (!tree.search(val).found) {
      tree.insert(val);
      inserted++;
    }
  }
  fb.textContent = `${inserted} valeurs aléatoires insérées.`;
  addHist(`Aléatoire (${inserted} valeurs)`);
  arrayDisplay.style.display = 'none';
  render();
};

document.getElementById("quickSortBtn").onclick = () => {
  if (tree.keyCount === 0) {
    fb.textContent = "L'arbre est vide.";
    arrayDisplay.style.display = 'none';
    return;
  }
  
  const sortedValues = tree.getSortedValues();
  displaySortedArray();
  fb.textContent = `Liste triée (${sortedValues.length} éléments)`;
  addHist(`Tri rapide - ${sortedValues.length} éléments`);
};

// Sauvegarde/Chargement
document.getElementById("saveTreeBtn").onclick = () => {
  const serialized = tree.serialize();
  localStorage.setItem('bplus_tree_save', serialized);
  saveFeedback.textContent = 'Arbre sauvegardé avec succès!';
  addHist('Arbre sauvegardé');
};

document.getElementById("loadTreeBtn").onclick = () => {
  const saved = localStorage.getItem('bplus_tree_save');
  if (!saved) {
    saveFeedback.textContent = 'Aucune sauvegarde trouvée.';
    return;
  }
  
  if (tree.deserialize(saved)) {
    saveFeedback.textContent = 'Arbre chargé avec succès!';
    fb.textContent = 'Arbre chargé depuis la sauvegarde.';
    addHist('Arbre chargé');
    arrayDisplay.style.display = 'none';
    render();
  } else {
    saveFeedback.textContent = 'Erreur lors du chargement de l\'arbre.';
  }
};

createTreeBtn.onclick = () => {
  const m = parseInt(orderInput.value);
  if (isNaN(m) || m < 3 || m > 9) {
    orderError.style.display = 'block';
    orderError.textContent = "L'ordre doit être entre 3 et 9";
    return;
  }
  
  if (m % 2 === 0) {
    orderError.style.display = 'block';
    orderError.textContent = "L'ordre doit être impair (3,5,7,9)";
    return;
  }
  
  orderError.style.display = 'none';
  tree.updateOrder(m);
  fb.textContent = `Arbre d'ordre ${m} créé.`;
  addHist(`Nouvel arbre d'ordre ${m}`);
  arrayDisplay.style.display = 'none';
  render();
};

orderInput.oninput = () => {
  const m = parseInt(orderInput.value);
  if (m % 2 === 0) {
    orderError.style.display = 'block';
    orderError.textContent = "L'ordre doit être impair (3,5,7,9)";
  } else {
    orderError.style.display = 'none';
  }
};

// Initialisation
orderInput.value = tree.order;
render();
</script>
</body>
</html>